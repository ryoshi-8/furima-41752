# 1. アプリケーションの新規作成手順 #
## 1-1. Railsアプリケーションの新規作成 ##
```
% cd ~/projects
% rails _7.1.0_ new protospace-テックマスターuser_id -d mysql
% cd protospace-”テックマスターuser_id”
```
## 1-2.データベースの作成 ##
database.ymlのencoding: utf8mb4をencoding: utf8へ修正後、
```
% rails db:create
```

# 　2.テーブルの設計 #
README.mdにテーブル設計を記述する。
## users テーブル

| Column             | Type   | Options                   |
| ------------------ | ------ | ------------------------- |
| email              | string | null: false, unique: true |
| encrypted_password | string | null: false               |
| name               | string | null: false               |
| profile            | text   | null: false               |
| occupation         | text   | null: false               |
| position           | text   | null: false               |

### Association

- has_many :prototypes
- has_many :comments

## prototypes テーブル

| Column     | Type       | Options                        |
| ---------- | ---------- | ------------------------------ |
| title      | string     | null: false                    |
| catch_copy | text       | null: false                    |
| concept    | text       | null: false                    |
| user       | references | null: false, foreign_key: true |

### Association

- belongs_to :user
- has_many :comments

## comments テーブル

| Column    | Type       | Options                        |
| --------- | ---------- | ------------------------------ |
| content   | text       | null: false                    |
| prototype | references | null: false, foreign_key: true |
| user      | references | null: false, foreign_key: true |

### Association

- belongs_to :user
- belongs_to :comment


# 3. #
prototypesコントローラーを作成した。
prototypesコントローラーにindexアクションを定義した（アクションの中には何も記述しない）。
viewsディレクトリの中の、prototypesコントローラーに対応するディレクトリにindex.html.erbを作成して、上記の記述をした。



# 4. #
ルートパスにアクセスしたときに、prototypesコントローラーのindexアクションを呼び出す記述をroutes.rbにした

# 5. #
- 既存のindex.html.erbを、配布済みのindex.html.erbに置き換えた
- 配布済みのstyle.cssを指示されたディレクトリに配置した
- 配布済みの画像を、指定されたディレクトリに配置した
- 既存のapplication.html.erbを、配布済みのapplication.html.erbに置き換えた
- サーバーを再起動して、ブラウザで表示を確かめた

# 6. ユーザー管理機能の実装
## 6-1. deviseの導入
deviseをGemfileの最終行に追加する。
```
gem 'devise'
```
プロジェクトフォルダでGemをインストールする。
```
bundle install
```
deviseの設定ファイルを作成する。
```
rails g devise:install
```
## 6-2. deviseでUserモデルを作成する
rails g devise userでUserモデルを作成する。
```
rails g devise user
```
マイグレーションファイルに、必要なカラム名を追記する。
マイグレーションを実行する。
```
rails db:migrate
```
- Userモデルに各カラムのバリデーションを記述する。
（「emailとpasswordが空だと保存できない」というバリデーションは標準で用意されているため、記述する必要はない）
- 正規表現を用いて


## 6-3. ビューファイルを適切なものに置き換えましょう #
- 配布済みのviews/deviseディレクトリを既存のviewsディレクトリに置き換えた

 ヘッダーの「新規登録」ボタンに適切なパスを記載した（devise/registrations#newに該当するパスを、rails routesを用いて確認する）\n

 registrations/new.html.erbのform_withのモデル名と新規登録機能へのパスを正しいものに修正した\n

 registrations/new.html.erbで「:hoge」と表記されている部分を、正しいものに修正した（PicTweetなどの新規登録ページも参考にする）

 application_controllerに、emailとpassword以外の値も保存できるように追記した（PicTweetなども参考にする）

```
class ApplicationController < ActionController::Base
  before_action :configure_permitted_parameters, if: :devise_controller?

  private
  def configure_permitted_parameters
    devise_parameter_sanitizer.permit(:sign_up, keys: [:nickname])
  end
end
```



 サーバーを再起動し、正しく新規登録ができることを確かめた

 Sequel Pro（Windowsの方はDBeaver）でusersテーブルに情報が保存されていることを確認した



- deviseでログイン機能を実装すると、ログイン/サインアップ画面が自動的に生成されますがビューファイルとしては生成されません。
これは、deviseのGem内に存在するビューファイルを読み込んでいるためです。

deviseのビューファイルに変更を加えるためには、deviseのコマンドを利用して、ビューファイルを生成する必要があります。

deviseでログイン機能を実装すると、ログイン/サインアップ画面が自動的に生成されますがビューファイルとしては生成されません。
これは、deviseのGem内に存在するビューファイルを読み込んでいるためです。

deviseのビューファイルに変更を加えるためには、deviseのコマンドを利用して、ビューファイルを生成する必要があります。
```
% rails g devise:views
```

## 6-4. 新規登録ができるようにしましょう #
- ヘッダーの「新規登録」ボタンに適切なパスを記載した（devise/registrations#newに該当するパスを、rails routesを用いて確認する）
- registrations/new.html.erbのform_withのモデル名と新規登録機能へのパスを正しいものに修正した
- registrations/new.html.erbで「:hoge」と表記されている部分を、正しいものに修正した
- application_controllerに、emailとpassword以外の値も保存できるように追記した
- サーバーを再起動し、正しく新規登録ができることを確かめた
- Sequel Pro（Windowsの方はDBeaver）でusersテーブルに情報が保存されていることを確認した

## 6-5. ログイン状態か否かでトップページの表示が変わるようにしましょう #
- ログイン状態では、トップページに「ユーザーのニックネーム」「ログアウト」が表示されて、ログアウト状態では、「ログイン」「新規登録」が表示されるように分岐した

## 6-6. ログイン・ログアウトができるようにしましょう #
- ヘッダーの「ログイン」ボタンに適切なパスを記載した（devise/sessions#newに該当するパスを、rails routesを用いて確認する）
- ヘッダーの「ログアウト」ボタンに適切なパスを記載した（devise/sessions#destroyに該当するパスを、rails routesを用いて確認する。HTTPメソッドの指定に注意。）
- sessions/new.html.erbのform_withのモデル名(@user)とログイン機能へのパスを正しいものに修正した
- sessions/new.html.erbで「:hoge」と表記されている部分を、正しいものに修正した
- サーバーを再起動し、ブラウザでログアウト/ログインができることを確認した
- バリデーションを設定して、情報が正しくない、情報が欠けている場合は、新規登録・ログインができないことを確認した。

# 7 Userモデルの単体テストをおこなう
## 7-1. RSpecのGemを追加する
Gemfileのgroup :development, :testというグループの中に記述する。

Gemfile
```
#中略
group :development, :test do
  # See https://guides.rubyonrails.org/debugging_rails_applications.html#debugging-with-the-debug-gem
  gem "debug", platforms: %i[ mri mingw x64_mingw ]
  gem 'rspec-rails', '~> 4.0.0'
end
#中略
```
bundle installを実行する。
```
% bundle install
```

## 7-2 RSpecの設定をしよう
### 7-2-1  RSpecをインストールする
```
% rails g rspec:install
```
### 7-2-2 .rspecに設定を追加する
生成された.rspecファイルを開き、以下のように記述する。
.rspec
```
--require spec_helper
--format documentation
```
## 7-3 pryのGemを追加する（まだ追加されてなければ）
Gemfile
```
~省略~
gem 'pry-rails'
```
bundle installを実行する。
```
% bundle install
```
## 7-4 FactoryBot, FakerのGemを導入する
Gemfileのgroup :development, :testというグループの中に記述する。
Gemfile
```ruby
group :development, :test do
  # See https://guides.rubyonrails.org/debugging_rails_applications.html#debugging-with-the-debug-gem
  gem "debug", platforms: %i[ mri mingw x64_mingw ]
  gem 'rspec-rails', '~> 4.0.0'
  gem 'factory_bot_rails'
  gem 'faker'
end
```
bundle installを実行する。
```
% bundle install
```


## 7-5 Userモデルのテストファイルを生成する
```
% rails g rspec:model user
```
テストファイルが生成されたか確認する
spec/models/user_spec.rb
```ruby
require 'rails_helper'

RSpec.describe User, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end
```

## 7-6 テストコードの雛形を記述する
spec/models/user_spec.rb
```ruby
require 'rails_helper'

RSpec.describe User, type: :model do
  describe 'ユーザー新規登録' do
    context '新規登録できるとき' do
      it 'nickname, email, password, password_confirmation, family_name, first_name, family_name_kana, first_name_kana, birthdayが存在すれば登録できる' do
      end
    end
    context '新規登録できないとき' do
      it 'nicknameが空では登録できない' do
        # nicknameが空では登録できないテストコードを記述します
      end
      it 'emailが空では登録できない' do
        # emailが空では登録できないテストコードを記述します
      end
      it 'メールアドレスが一意性であること' do
      end
      it 'メールアドレスは、@を含む必要があること。' do
      end
      it 'パスワードが必須であること。' do
      end
      it 'パスワードは、6文字以上での入力が必須であること' do
      end
      it 'パスワードは、半角英数字混合での入力が必須であること' do
      end
      it 'パスワードとパスワード（確認）は、値の一致が必須であること。' do
      end
      it 'お名前(全角)は、名字と名前がそれぞれ必須であること' do
      end
      it 'お名前(全角)は、全角（漢字・ひらがな・カタカナ）での入力が必須であること。' do
      end
      it 'お名前カナ(全角)は、名字と名前がそれぞれ必須であること。' do
      end
      it 'お名前カナ(全角)は、全角（カタカナ）での入力が必須であること。' do
      end
      it '生年月日が必須であること。' do
      end
    end
  end
end
```
## 7-8 FactoryBotの記述を編集する
spec/factories/users.rb
```ruby
FactoryBot.define do
  factory :user do
    nickname              {'test'}
    email                 {'test@example'}
    password              {'000000'}
    password_confirmation {password}
  end
end
```
さて、この設定したインスタンスを生成するためには、FactoryBot.build(:user)という記述をテストコードの中に記述します。


## 7-9 テストコード（異常系）実装の流れ
1. 検証のためのインスタンスを生成する
nicknameではなくemailを空にしてインスタンスを生成します。nicknameには空以外の値を入力しておきましょう。

2. 生成したインスタンスに対してバリデーションを行う
2は前述の実装と同様です。valid?メソッドを用いてバリデーションを行ってください。

3. バリデーションを行ったあとに生成されるエラーメッセージが、どのような状態であればよいのかを指定する
適切なメソッドやマッチャを用いて、エクスペクテーションを完成させましょう。


## 7-10 テストコードを実行するには
```
% bundle exec rspec spec/models/user_spec.rb 
```

# 8 商品投稿機能の実装
## 8-1 Itemモデルおよびテーブルを作成する
Itemモデルを作成する
```
% rails g model item
```
README.md, ER図をもとにマイグレーションファイルに、必要なカラム名を追記する。

マイグレーションを実行する。
```
rails db:migrate
```

## 8-2 アソシエーションを記述する
- Itemモデル、Userモデルにアソシエーション記述する。

## 8-3 Active Storageを導入する（画像投稿のため）
ImageMagickがインストールされているか確認する。
```
brew list
```
### 8-3-1 mini_magickとimage_processingの追加
Gemfileの一番下に記述する
```
gem 'mini_magick'
gem 'image_processing', '~> 1.2'
```
```
% bundle install
```

### 8-3-2 MiniMagick使用のため、設定ファイルに記述をする

config/application.rb
```ruby
＜省略＞

module ChatApp

  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 7.0
    config.i18n.default_locale = :ja
    config.time_zone = 'Tokyo'
    config.active_storage.variant_processor = :mini_magick

＜省略＞
```
上記設定後、ローカルサーバーを再起動する。


### 8-3-3 Active Storageをインストールする
```
% rails active_storage:install
```
Active Storage関連マイグレーション作成後、続けてマイグレートする。
```
% rails db:migrate
```

### 8-3-4 Active StorageのテーブルとItemsテーブルのアソシエーションを定義(Messagesテーブルに画像ファイルを紐付け)
```ruby
class Item < ApplicationRecord
  belongs_to :user
  has_one_attached :image
end
```
このとき、itemsテーブルにカラムを追加する必要はない。

### 8-3-5 items_controller.rbにて、imageカラムの保存を許可
imageでアクセル可能となった画像ファイルの保存を許可する実装を行う。
items_controller.rbのストロングパラメーター定義部分を以下のように編集する。
```ruby
class ItemsController < ApplicationController
  def index
  end

  def item_params
    params.require(:item).permit(:image).merge(user_id: current_user.id)
  end
end
```

## 8-4 ActiveHashを導入する
### 8-4-1 ActiveHashを導入する
商品投稿の際、選択項目で入力できるようにActiveHashを導入する。
Gemfileの一番下に記述する
```
#中略
gem 'active_hash'
```
記述したらbundle installを実行する。
```
% bundle install
```
### 8-4-2 ActiveHashを利用するモデルファイルを作成する(5つの選択項目)
app/modelsフォルダに作成したいモデル名でファイルを作成する。
＜例＞
app/models/prefecture.rb
```ruby
% touch app/models/prefecture.rb 
```
### 8-4-3 ActiveHashモデルファイルにデータを定義する
＜例＞「Prefectureクラス」を定義し、ActiveHash::Baseクラスを継承する。

app/models/prefecture.rb
```ruby
class Prefecture < ActiveHash::Base
  self.data = [
    { id: 1, name: '---' },
    { id: 2, name: '北海道' },
    { id: 3, name: '青森県' },
＜省略＞
    { id: 46, name: '宮崎県' }
    { id: 47, name: '鹿児島県' }
    { id: 48, name: '沖縄県' }
  ]
end
```


### 8-4-4 ActiveHashを利用する５つのモデルファイルとItemモデル（商品）のアソシエーションを記述する（belongs_toメソッドを使用する）

#### Itemモデルのアソシエーションを設定する。
- 投稿する商品は、1つのcategoryに紐付いている。そのため、Itemモデルにはbelongs_toを設定する。
- ActiveHashを用いて、belongs_toを設定するには、
extend ActiveHash::Associations::ActiveRecordExtensionsと記述してmoduleを取り込む。

app/models/item.rb
```ruby
class Item < ApplicationRecord
  belongs_to :user
  has_one_attached :image

  extend ActiveHash::Associations::ActiveRecordExtensions
  belongs_to :category
  belongs_to :condition
  belongs_to :ship_fee_burden
  belongs_to :prefecture
  belongs_to :days_until_ship
end
```

#### Categoryモデル(＋その他のモデル)のアソシエーションを設定する。
- 1つのcategoryは、たくさんの商品投稿に紐付いています。そのため、Categoryモデルにはhas_manyを設定する。
- ActiveHashを用いて、has_manyを設定するには、
include ActiveHash::Associationsと記述してmoduleを取り込む。
app/models/category.rb
```ruby
class Category < ActiveHash::Base
  self.data = [
    { id: 1, name: '---' },
    { id: 2, name: 'メンズ' },
    { id: 3, name: 'レディース' },
    { id: 4, name: 'ベビー・キッズ' },
    { id: 5, name: 'インテリア・住まい・小物' },
    { id: 6, name: '本・音楽・ゲーム' },
    { id: 7, name: 'おもちゃ・ホビー・グッズ' },
    { id: 8, name: '家電・スマホ・カメラ' },
    { id: 9, name: 'スポーツ・レジャー' },
    { id: 10, name: 'ハンドメイド' },
    { id: 11, name: 'その他' }
  ]

  include ActiveHash::Associations
  has_many :items
end
```
その他のモデルにもhas_manyを設定する。

## 8-5 Itemモデルにバリデーションを設定する
データベースに空の投稿が保存されないようにバリデーションを設定する。
app/models/item.rb
```ruby
class Item < ApplicationRecord
  belongs_to :user
  has_one_attached :image

  extend ActiveHash::Associations::ActiveRecordExtensions
  belongs_to :category
  belongs_to :condition
  belongs_to :ship_fee_burden
  belongs_to :prefecture
  belongs_to :days_until_ship

  with_options presence: true do
    validates :product_name
    validates :description
    validates :price
  end

  with_options numericality: { other_than: 1 } do
    validates :category_id
    validates :condition_id
    validates :ship_fee_burden_id
    validates :prefecture_id
    validates :days_until_ship_id
  end
end
```




# アクションとルーティングを設定しましょう
今回の投稿機能に必要な、アクションとルーティングを設定しましょう。
- prototypesコントローラーにnewアクションとcreateアクションを設定した（まだアクション内の処理は書かない）- resourcesを用いて、上記で設定したnewアクションとcreateアクションに対するルーティングをroutes.rbに記述した
- rails routesを実行して、ルーティングが正しく設定できていることを確かめた

## 8-6 商品出品ページを表示できるようにする（newアクション）
次に、トップページから商品出品ボタンを押したとき、商品出品ページを表示できるようにしましょう。


商品に関する処理を行うコントローラーに、newアクションを定義しましょう。


## 8-7 出品した商品の情報をテーブルに保存できるようにする（createアクション）
出品ページから出品するボタンを押したときに入力した商品情報をデータベースに保存できるようにしましょう。

### 8-7-1 newアクションのルーティングを設定する
投稿画面へ遷移するために、newアクションへのルーティングを設定する。
config/routes.rb
```ruby
Rails.application.routes.draw do
  devise_for :users
  root to: "items#index"
  resources :items, only: [:index, :new]
end
```
### 8-7-2 newアクションをコントローラーに定義する
app/controllers/items_controller.rb
```ruby
class ItemsController < ApplicationController
  def index
  end

  def new
    @item = Item.new
  end

  def item_params
    params.require(:item).permit(:image).merge(user_id: current_user.id)
  end
end
```

### 8-7-3 商品出品画面（投稿画面）のビューを作成する
- app/views/itemsにnew.html.erbというビューファイルを作成する（セレクトボックスを利用するなど。）
- ログアウト状態のユーザーが商品出品ページへ遷移しようとすると、ログインページへリダイレクトするように実装する。
app/controllers/items_controller.rb
```ruby
class ItemsController < ApplicationController
  before_action :authenticate_user!, only: :new
＜省略＞
```


# 適切なビューファイルを設定しましょう #
すでにダウンロード済みのビューファイルから、新規投稿に関するビューファイルと投稿フォームに関する部分テンプレートを選択し、配置しましょう。
- views/prototypesの中に、配布済みのnew.html.erbと_form.html.erbを配置した

# 投稿機能を実装しましょう #
投稿機能を実装しましょう。このとき、必要な値が入力されておらずバリデーションによって保存が出来ない場合の処理についても実装します。具体的には、renderを用いて投稿ページのビューファイルを表示するようにします。注意点として、バリデーションによって保存ができなかった場合でも、画像以外の入力項目は消えないように実装しましょう。

- ヘッダーの「New Proto」ボタンから、新規投稿ページに遷移するようにパスを設定した（rails routesを用いて確認する）
- newアクションにインスタンス変数@prototypeを定義し、Prototypeモデルの新規オブジェクトを代入した
- new.html.erbから部分テンプレートである、_form.html.erbを呼び出す記述をした
- _form.html.erbのform_withのモデル名を正しいものに修正した
- _form.html.erbで「:hoge」と記載されている部分を、正しいものに修正した
- prototypesコントローラーのprivateメソッドにストロングパラメーターをセットし、特定の値のみを受け付けるようにした。且つ、user_idもmergeした
- createアクションにデータ保存のための記述をし、保存されたときはルートパスに戻るような記述をした
- createアクションに、データが保存されなかったときは新規投稿ページへ戻るようrenderを用いて記述した
- バリデーションによって保存ができず投稿ページへ戻ってきた場合でも、入力済みの項目（画像以外）は消えないことを確認した
- サーバーを再起動し、ブラウザで正しく動くか確認した
- Sequel Pro（Windowsの方はDBeaver）を確認して、正しく保存ができているか確認した

# 投稿したプロトタイプがトップページで表示されるようにしましょう #
テーブルに保存されているすべてのプロトタイプが、トップページに表示されるようにしましょう。各プロトタイプのリンクは、仮置きのままで問題ありません。

- 各プロトタイプを表示するための部分テンプレート_prototype.html.erbを、views/prototypesの中に配置した
- indexアクションに、インスタンス変数@prototypesを定義し、すべてのプロトタイプの情報を代入した
- index.html.erbから_prototype.html.erbを呼び出し、プロトタイプ毎に、画像・プロトタイプ名・キャッチコピー・投稿者の名前を表示できるようにした（renderメソッドにcollectionオプションを用いて実装する）
- 正しくプロトタイプの表示ができるように、_prototype.html.erbを編集した（ただし仮置きのリンクroot_pathはそのままで良い）
- ブラウザで正しく表示されるか確認した

# プロトタイプの詳細ページを実装しよう #
トップページのプロトタイプをクリックすると、以下のように詳細ページが表示されるようにしましょう。「編集」「削除」については、そのプロトタイプを投稿したユーザー以外には表示されません。

## アクションとルーティングを設定しましょう ##
今回の詳細ページ機能に必要な、アクションとルーティングを設定しましょう。
- prototypesコントローラーにshowアクションを設定した（まだアクション内の処理は書かない）
- resourcesを用いて、上記で設定したshowアクションに対するルーティングをroutes.rbに記述した
- rails routesを実行して、ルーティングが正しく設定できていることを確かめた

# 適切なビューファイルを設置しましょう #
すでにダウンロード済みのビューファイルから、詳細ページに関するビューファイルを選択し、配置しましょう。
- views/prototypesの中に、配布済みのshow.html.erbを配置した

# 詳細ページで投稿の情報が表示されるようにしましょう #
遷移先の詳細ページで、そのプロトタイプの情報が過不足無く表示されるようにしましょう。

- showアクションにインスタンス変数@prototypeを定義した。且つ、Pathパラメータで送信されるID値で、Prototypeモデルの特定のオブジェクトを取得するように記述し、それを@prototypeに代入した
- show.html.erbにおいて、プロトタイプの「プロトタイプ名」「投稿者」「画像」「キャッチコピー」「コンセプト」が表示されるように記述を変更した
- 詳細ページに遷移し、プロトタイプの「プロトタイプ名」「投稿者」「画像」「キャッチコピー」「コンセプト」が正しく表示されることを確認した

# 投稿したユーザーだけに「編集」「削除」のボタンが表示されるようにしましょう #
投稿者だけに「編集」「削除」のボタンが表示されるようにしましょう。この時、リンク先は現状の仮置きのままで問題ありません。

- ログインしているユーザーがそのプロトタイプの投稿者であるときは、「編集」「削除」のボタンが表示されるように条件分岐した（ボタンのリンク先は仮置きのroot_pathのままでよい）
- ブラウザで正しく動くか確認した

# プロトタイプ情報の編集機能を実装しよう #
詳細ページからプロトタイプ編集ページに遷移し、正しく編集できると詳細ページに戻るように実装することをゴールとします。空の入力欄がある場合は、編集できずにそのページに留まるようにします。

## アクションとルーティングを設定しましょう ##
- prototypesコントローラーにeditアクションとupdateアクションを設定した（まだアクション内の処理は書かない）
- resourcesを用いて、上記で設定したeditアクションとupdateアクションに対するルーティングをroutes.rbに記述した
- rails routesを実行して、ルーティングが正しく設定できていることを確かめた

# 適切なビューファイルを設定しましょう #
すでにダウンロード済みのビューファイルから、編集機能に関するビューファイルを選択し、配置しましょう。
- views/prototypesの中に、配布済みのedit.html.erbを配置した

# 詳細ページから編集ページに遷移できるようにしましょう #
- show.html.erbの「編集する」ボタンから、編集ページに遷移するようにパスを設定した（パスはrails routesを用いて確認する）

